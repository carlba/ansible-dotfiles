---

- hosts: all
  tasks:

  - name: Ensure it is possible to use md5sum
    package: name=md5sha1sum

  - name: Speed up dock autohide
    osx_defaults:
      domain: com.apple.dock
      key: autohide-time-modifier
      type: int
      value: 0
      state: present

  - name: Speed up dock autohide
    osx_defaults:
      domain: com.apple.dock
      key: autohide-delay
      type: float
      value: 0.0
      state: present

  - name: Promt on quit
    osx_defaults:
      domain: com.googlecode.iterm2
      key: PromptOnQuit
      type: string
      value: 0
      state: present

  - name: Ensure MacOS doesn't read .DS_Store from network storage
    osx_defaults:
      domain: com.apple.desktopservices
      key: DSDontWriteNetworkStores
      type: bool
      value: true
      state: present

  - name: Create KeyBindings Directory
    file:
      path: "{{ ansible_env.HOME }}/Library/KeyBindings"
      state: directory

  - name: Remap home and end to linux behaviour
    blockinfile:
      marker: "/* {mark} ANSIBLE MANAGED BLOCK (Remap home and end to linux behaviour) */"
      dest: "{{ ansible_env.HOME }}/Library/KeyBindings/DefaultKeyBinding.dict"
      create: true
      block: |
        {
            "\UF729" = "moveToBeginningOfLine:"; /* Home */
            "\UF72B" = "moveToEndOfLine:"; /* End */
            "$\UF729" = "moveToBeginningOfLineAndModifySelection:"; /* Shift + Home */
            "$\UF72B" = "moveToEndOfLineAndModifySelection:"; /* Shift + End */
            "^\UF729" = "moveToBeginningOfDocument:"; /* Ctrl + Home */
            "^\UF72B" = "moveToEndOfDocument:"; /* Ctrl + End */
            "$^\UF729" = "moveToBeginningOfDocumentAndModifySelection:"; /* Shift + Ctrl + Home */
            "$^\UF72B" = "moveToEndOfDocumentAndModifySelection:"; /* Shift + Ctrl + End */
        }

  # Creates an entry like "PATH=/opt/bin" on top of crontab
  - name: Add path to crontab
    cron:
      name: PATH
      env: true
      value: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
    tags: cron

  - name: Ensure cronjob that clears Google Chrome history daily exists
    cron:
      name: "Clear Google Chrome history"
      user: "{{ ansible_env.USER }}"
      job: rm -rf /Users/cada/Library/Application Support/Google/Chrome/Default/History*
    tags: cron

  - name: Add Karabiner-Elements
    homebrew_cask:
      name: Karabiner-Elements

  - name: Ensure Karabiner config directory exists
    file:
      path: "{{ ansible_env.USER }}/.config/karabiner"
      state: directory

  - name: Add Karabiner-Elements config to map caps lock to F19
    template:
      src: karabiner.json.j2
      dest: "{{ ansible_env.HOME }}/.config/karabiner/karabiner.json"

  # TODO: Only add the login item if it doesn't exist
  - name: Ensure Karabiner-Elements is launched on startup
    shell: >
      osascript -e 'tell application "System Events" to make login item at end with properties
      {path:"/Applications/Karabiner-Elements.app", hidden:true}'
    when: false

  - name: Get status of Kernel Extension User Consent
    become: true
    shell: spctl --status
    register: spctl_output
    ignore_errors: true

  - name: Ensure fix damaged app message on macOS Sierra doesn't appear
    become: true
    shell: spctl --master-disable
    when: not "assessments disabled" == spctl_output.stdout

  - stat: path="/Applications/CleanMyMac X.app"
    register: clean_my_mac_path
    tags: clean_my_mac

  - name: Ensure temp CleanMyMac folder exist
    file:
      path: /tmp/clean_my_mac
      state: directory
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: Ensure temp CleanMyMac folder exist
    copy:
      src: resources/CleanMyMac_X_4.0.3__TNT_.dmg
      dest: /tmp/clean_my_mac
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: mount the downloaded dmg
    shell: hdiutil attach /tmp/clean_my_mac/CleanMyMac_X_4.0.3__TNT_.dmg -nobrowse
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: mount the downloaded dmg
    shell: >
      hdiutil attach "/Volumes/CleanMyMac X 4.0.3/Manual install/CleanMyMac X 4.0.3 [TNT].dmg"
      -nobrowse
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: Ensure the application is copied to Applications
    become: true
    shell: cp -r "/Volumes/CleanMyMac X 4.0.3 1/CleanMyMac X.app" /Applications
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: unmount the downloaded dmg
    become: true
    shell: hdiutil detach "/Volumes/CleanMyMac X 4.0.3 1"
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: unmount the downloaded dmg
    become: true
    shell: hdiutil detach "/Volumes/CleanMyMac X 4.0.3"
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: Ensure the CleanMyMac temp directory is removed
    file:
      path: /tmp/clean_my_mac
      state: absent
    when: not clean_my_mac_path.stat.exists
    tags: clean_my_mac

  - name: Ensure watch CLI tool is installed
    package:
      name: watch
      state: present
    tags: cli

  - name: Ensure locate service is autostarted and running
    become: true
    shell: launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist
    tags: service

  - stat: path="/Applications/DaisyDisk.app"
    register: daisydisk_path
    tags: daisydisk

  - name: Ensure temp DaisyDisk folder exist
    file:
      path: /tmp/daisy_disk
      state: directory
    when: not daisydisk_path.stat.exists
    tags: daisydisk

  - name: Ensure DaisyDisk zip-file is unarchived into it's temp folder
    unarchive:
      src: 'resources/DaisyDisk 4.6.5.zip'
      dest: /tmp/daisy_disk
    when: not daisydisk_path.stat.exists
    tags: daisydisk

  - name: Ensure the DaisyDisk .app file is copied to Applications
    copy:
      src: '/tmp/daisy_disk/DaisyDisk.app'
      dest: /Applications
    when: not daisydisk_path.stat.exists
    tags: daisydisk

  - name: Ensure temp DaisyDisk folder does not exist
    file:
      path: /tmp/daisy_disk
      state: absent
    when: not daisydisk_path.stat.exists
    tags: daisydisk

  - stat: path="/Applications/Fantastical 2.app"
    register: fantastical_path
    tags: fantastical

  - name: Set variables
    set_fact:
      fantastical_version: 2.5.8
      fantastical_dmg_filename: Fantastical_2.5.8__TNT_.dmg
      fantastical_nested_dmg_filename: Fantastical 2.5.8 [TNT].dmg
      fantastical_app_name: Fantastical 2.app
    tags: fantastical

  - name: Ensure temp Fantastical folder exist
    file:
      path: /tmp/fantastical
      state: directory
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure Fantastical dmg-file exists in Fantastical temp folder
    copy:
      src: 'resources/{{ fantastical_dmg_filename }}'
      dest: /tmp/fantastical
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure Fantastical dmg-file is mounted
    shell: 'hdiutil attach /tmp/fantastical/{{ fantastical_dmg_filename }} -nobrowse'
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure the installation dmg-file within the Fantastical dmg-file is mounted
    shell:
      "hdiutil attach '/Volumes/Fantastical {{ fantastical_version }}/Manual install/\
      {{ fantastical_nested_dmg_filename }}' -nobrowse"
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure the old Fantastical .app folder is removed
    file:
      path: '/Applications/{{ fantastical_app_name }}'
      state: absent
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure the Fantastical .app folder is copied to Applications
    synchronize:
      src: '/Volumes/Fantastical {{ fantastical_version }} 1/{{ fantastical_app_name }}'
      dest: /Applications/
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure the dmg nested in the downloaded dmg is unmounted
    shell: 'hdiutil detach "/Volumes/Fantastical {{ fantastical_version }} 1"'
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure the downloaded dmg is unmounted
    shell: 'hdiutil detach "/Volumes/Fantastical {{ fantastical_version }}"'
    when: not fantastical_path.stat.exists
    tags: fantastical

  - name: Ensure temp Fantastical folder does not exist
    file:
      path: /tmp/fantastical
      state: absent
    when: not fantastical_path.stat.exists
    tags: fantastical

# TODO: This should be converted into a role
  - name: Set variables
    set_fact:
      application_version: 4.5.2
      application_dmg_filename: Dash_4.5.2__TNT_.dmg
      application_app_name: Dash.app
      application_name: Dash
    tags: application

  - name: Ensure temp Application folder exist
    file:
      path: '/tmp/{{ application_name }}'
      state: directory
    tags: application

  - name: Ensure Application dmg-file exists in Application temp folder
    copy:
      src: 'resources/{{ application_dmg_filename }}'
      dest: '/tmp/{{ application_name }}'
    tags: application

  - name: Ensure Application dmg-file is mounted
    shell: 'hdiutil attach /tmp/{{ application_name }}/{{ application_dmg_filename }} -nobrowse'
    tags: application

  - name: Find the dmg-file nested in the Application dmg-file
    find:
      paths: '/Volumes'
      patterns: '{{ application_name }} {{ application_version}}*.dmg'
      recurse: yes
    register: find_nested_dmg_result
    tags: application

  - name: Ensure the installation dmg-file within the Application dmg-file is mounted
    shell:
      "hdiutil attach '{{ find_nested_dmg_result.files[0].path }}' -nobrowse"
    tags: application

  - name: Ensure the old Application .app folder is removed
    file:
      path: '/Applications/{{ application_app_name }}'
      state: absent
    tags: application

  - name: Ensure the Application .app folder is copied to Applications
    synchronize:
      src: '/Volumes/{{ application_name }} {{ application_version }} 1/{{ application_app_name }}'
      dest: /Applications/
    tags: application

  - name: Ensure the dmg nested in the downloaded dmg is unmounted
    shell: 'hdiutil detach "/Volumes/{{ application_name }} {{ application_version }} 1"'
    tags: application

  - name: Ensure the downloaded dmg is unmounted
    shell: 'hdiutil detach "/Volumes/{{ application_name }} {{ application_version }}"'
    tags: application

  - name: Ensure temp Application folder does not exist
    file:
      path: '/tmp/{{ application_name }}'
      state: absent
    tags: application

  - name: Ensure mas (MacOS Appstore CLI) and my favorite apps is installed
    include_role:
      name: geerlingguy.mas
    when: false
    vars:
      mas_email: '{{ apple_id_username }}'
      mas_password: '{{ apple_id_password }}'
      mas_installed_apps:
        - { id: 414030210, name: 'LimeChat (2.43)' }
        - { id: 425424353, name: 'The Unarchiver (4.0.0)' }
        - { id: 585829637, name: 'Todoist (7.1.1)' }
        - { id: 936243210, name: 'MiniPlay (1.4.3)' }
        - { id: 1254743014, name: 'LyricsX (1.4.2)' }
        - { id: 937984704, name: 'Amphetamine (4.0.5)' }
        - { id: 822514576, name: 'SonicWall Mobile Connect (5.0.2)' }
        - { id: 692867256, name: 'Simplenote (1.3.9)' }
        - { id: 414030210, name: 'LimeChat (2.43)' }
      mas_upgrade_all_apps: true

  - name: Ensure alfred is installed
    homebrew_cask:
      name: alfred

  - name: Ensure alfred-jetbrains-workflow is installed
    npm:
      name: '@bchatard/alfred-jetbrains'
      global: yes

  - name: Ensure Plex is installed
    homebrew_cask:
      name: plex
    tags: plex

  - name: Ensure VSCode is installed
    homebrew_cask:
      name: visual-studio-code
    tags: vscode

  # Required for https://github.com/carlba/syncify
  - name: Ensure pigz is installed
    package:
      name: pigz
    tags: syncify

